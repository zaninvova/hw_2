# Исполнитель Черепаха

## Базовый синтаксис

Прежде чем приступить к выполнению задания вспомним базовый синтаксис языка Python:

### Типы данных

Python умеет работать как минимум с двумя видами данных — числами и строками. Числа записываются последовательностью цифр, также перед числом может стоять знак минус, а строки записываются в одинарных кавычках. `2` и `'2'` — это разные объекты, первый объект — число, а второй — строка. Операция + для целых чисел и для строк работает по-разному: для чисел это сложение, а для строк — конкатенация.

Кроме целых чисел есть и другой класс чисел: действительные (вещественные числа), представляемые в виде десятичных дробей. Они записываются с использованием десятичной точки, например, `2.0.`

Определить тип объекта можно при помощи функции `type`:

```python
>>> type(2)
<class 'int'>
>>> type('2')
<class 'str'>
>>> type(2.0)
<class 'float'>
```

Обратите внимание — `type` является функцией, аргументы функции указываются в скобках после ее имени.

### Операции с числами

Вот список основных операций для чисел:

| # | Операция | Описание             |
|---|----------|----------------------|
| 1 | `A+B`    | сумма                |
| 2 | `A-B`    | разность             |
| 3 | `A*B`    | произведение         |
| 4 | `A/B`    | частное              |
| 5 | `A**B`   | возведение в степень |

Полезно помнить, что квадратный корень из числа `x` — это `x**0.5`, а корень степени `n` — это `x**(1/n)`.

Есть также унарный вариант операции `-`, то есть операция с одним аргументом. Она возвращает число, противоположное данному. Например: `-A`.

В выражении может встречаться много операций подряд. Как в этом случае определяется порядок действий? Например, чему будет равно `1+2*3**1+1`? В данном случае ответ будет `8`, так как сначала выполняется возведение в степень, затем — умножение, затем — сложение.

Более общие правила определения приоритетов операций такие:

1. Выполняются возведения в степень справа налево, то есть `3**3**3` это `3²⁷`.
2. Выполняются унарные минусы (отрицания).
3. Выполняются умножения и деления слева направо. Операции умножения и деления имеют одинаковый приоритет.
4. Выполняются сложения и вычитания слева направо. Операции сложения и вычитания имеют одинаковый приоритет.

### Операции над строками

| # | Операция | Описание                                                |
|---|----------|---------------------------------------------------------|
| 1 | `A+B`    | конкатенация                                            |
| 2 | `A*n`    | повторение  n раз, значение  n должно быть целого типа. |

### Ветвление

Ветвление (или условная инструкция) в Python имеет следующий синтаксис:

```python
if Условие:
    Блок_инструкций_1
else:
    Блок_инструкций_2
```

`Блок_инструкций_1` будет выполнен, если `Условие` истинно. Если Условие ложно, будет выполнен `Блок_инструкций_2`.

В условной инструкции может отсутствовать слово else и последующий блок. Такая инструкция называется неполным ветвлением. Например, если дано число x и мы хотим заменить его на абсолютную величину x, то это можно сделать следующим образом:

```python
if x < 0:
    x = -x
print(x)
```

В этом примере переменной `x` будет присвоено значение `-x`, но только в том случае, когда `x<0`. А вот инструкция `print(x)` будет выполнена всегда, независимо от проверяемого условия.

Для выделения блока инструкций, относящихся к инструкции `if`, `elif` или `else` в языке Python используются отступы. Все инструкции, которые относятся к одному блоку, должны иметь равную величину отступа, то есть одинаковое число пробелов в начале строки. Рекомендуется использовать **отступ в 4 пробела или одну табуляцию**.

### Вложенные условные инструкции

Внутри условных инструкций можно использовать любые инструкции языка Python, в том числе и условную инструкцию. Вложенное ветвление — после одной развилки в ходе исполнения программы появляется другая развилка. При этом вложенные блоки имеют больший размер отступа (например, 8 пробелов или 2 табуляции).

Примере программы, которая по данным ненулевым числам `x` и `y` определяет, в какой из четвертей координатной плоскости находится точка `(x,y)`:

![](https://cpp.mazurok.com/wp-content/uploads/2017/12/CHisl-okr-chetverti1.png)

```python
x = int(input())
y = int(input())
if x > 0:
   if y > 0:               # x>0, y>0
      print("Первая четверть")
   else:                   # x>0, y<0
      print("Четвертая четверть")
else:
   if y > 0:               # x<0, y>0
      print("Вторая четверть")
   else:                   # x<0, y<0
      print("Третья четверть")
```

В этом примере мы использовали *комментарии* – текст, который интерпретатор игнорирует. Комментариями в Pythonе является символ `#` и весь текст после этого символа до конца строки. Желательно писать код так, чтобы комментарии были излишними, однако допускается писать их там, где возникают "призраки" (утверждения или теоремы, которые использованы при написании кода, но не следуют из самого кода). Однако код выше является плохим примером документации: комментарии врут, поскольку автором не учтены точки на осях.

### Операнды и операторы
Большинство предложений (логических строк) в программах содержат выражения. Простой пример *выражения*: `2 + 3`. Выражение можно разделить на операторы и операнды.

**Операторы** – это некий функционал, производящий какие-либо действия, который может быть представлен в виде *символов*, как например `+`, **или** специальных **зарезервированных слов**. Операторы могут производить некоторые действия над данными, и эти данные называются операндами. В нашем случае `2` и `3` – это операнды.

Примеры **операндов**:

```python
a += 1      # a - операнд
a + b + c   # a, b, c - операнды
```
**Оператор** представляет собой символическое обозначение некоторого действия, выполняемого с операндами в выражении.
в примере выше оператарами является `+=` и `+`

Полный перечень операторов в языке Python:

| # | Оператор | Наименование | Описание | Пример |
|---|----------|-----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1 | `+` | Сложение | Суммирует два объекта | `3 + 5` даст `8`; `'a' + 'b'` даст `'ab'` |
| 2 | `-` | Вычитание | Даёт разность двух чисел; если первый операнд отсутствует, он считается равным нулю | `-5.2` даст отрицательное число, а `50 - 24` даст `26` |
| 3 | '*' | Умножение | Даёт произведение двух чисел или возвращает строку, повторённую заданное число раз. | `2 * 3` даст `6`. `'la' * 3` даст `'lalala'`. |
| 4 | '**' | Возведение в степень | Возвращает число `х`, возведённое в степень `y` | `3 ** 4` даст `81` (т.е. `3 * 3 * 3 * 3`) |
| 5 | '/' | Деление | Возвращает частное от деления `x` на `y` | `4 / 3` даст `1.3333333333333333` |
| 6 | `//` | Целочисленное деление | Возвращает неполное частное от деления | `4 // 3` даст `1`. `-4 // 3` даст `-2` |
| 7 | `%` | Деление по модулю | Возвращает остаток от деления | `8 % 3` даст `2`. `-25.5 % 2.25` даст `1.5` |
| 8 | `<<` | Сдвиг влево | Сдвигает биты числа влево на заданное количество позиций. (Любое число в памяти компьютера представлено в виде битов - или двоичных чисел, т.е. 0 и 1) | `2 << 2` даст `8`. В двоичном виде `2` представляет собой `10`. Сдвиг влево на `2` бита даёт `1000`, что в десятичном виде означает `8` |
| 9 | `>>` | Сдвиг вправо | Сдвигает биты числа вправо на заданное число позиций. | `11 >> 1` даст `5`. В двоичном виде `11` представляется как `1011`, что будучи смещённым на `1` бит вправо, даёт `101`, а это, в свою очередь, не что иное как десятичное `5` |
| 10 | `&` | Побитовое И | Побитовая операция **И** над числами | `5 & 3` даёт `1` |
| 11 | `|` | Побитовое ИЛИ | Побитовая операция **ИЛИ** над числами | `5 | 3` даёт `7` |
| 12 | `^` | Побитовое ИСКЛЮЧИТЕЛЬНО ИЛИ | Побитовая операция **ИСКЛЮЧИТЕЛЬНО ИЛИ** | `5 ^ 3` даёт `6` |
| 13 | `~` | Побитовое НЕ | Побитовая операция **НЕ** для числа `x` соответствует `-(x+1)` | `~5` даёт `-6` |
| 14 | `<` | Меньше | Определяет, верно ли, что `x` меньше `y`. Все операторы сравнения возвращают `True` или `False` | `5 < 3` даст `False`,а `3 < 5` даст `True`. Можно составлять произвольные цепочки сравнений: `3 < 5 < 7` даёт `True` |
| 15 | `>` | Больше | Определяет, верно ли, что `x` больше `y` | `5 > 3` даёт `True`. Если оба операнда - числа, то перед сравнением они оба преобразуются к одинаковому типу. В противном случае всегда возвращается `False` |
| 16 | `<=` | Меньше или равно | Определяет, верно ли, что `x` меньше или равно `y` | `x = 3; y = 6; x <= y` даёт `True` |
| 17 | `>=` | Больше или равно | Определяет, верно ли, что `x` больше или равно `y` | `x = 4; y = 3; x >= 3` даёт `True` |
| 18 | `==` | Равно | Проверяет, одинаковы ли объекты | `x = 2; y = 2; x == y` даёт `True`. `x = 'str'; y = 'stR'; x == y` даёт `False`. `x = 'str'; y = 'str'; x == y` даёт `True` |
| 19 | '!=' | Не равно | Проверяет, верно ли, что объекты не равны | `x = 2; y = 3; x != y` даёт `True` |
| 20 | 'not' | Логическое НЕ | Если `x` равно `True`, оператор вернёт `False`. Если же `x` равно `False`, получим `True` | `x = True; not x` даёт `False` |
| 21 | 'and' | Логическое И | `x and y` даёт `False`, если `x` равно `False` , в противном случае возвращает значение `y` | `x = False; y = True; x and y` возвращает `False`, поскольку `x` равно `False`. В этом случае Python не станет проверять значение `y`, так как уже знает, что левая часть выражения `and` равняется `False`, что подразумевает, что и всё выражение в целом будет равно `False`, независимо от значений всех остальных операндов. Это называется укороченной оценкой булевых (логических) выражений. |
| 22 | 'or' | Логическое ИЛИ | Если `x` равно `True`, в результате получим `True`, в противном случае получим значение `y` | `x = True; y = False; x or y` даёт `True` |

### Операторы сравнения


Как правило, в качестве проверяемого условия используется результат вычисления одного из следующих операторов сравнения:

| # | Оператор | Описание                                                                        |
|---|----------|---------------------------------------------------------------------------------|
| 1 | `<`      | Меньше — условие верно, если первый операнд меньше второго                      |
| 2 | `>`      | Больше — условие верно, если первый операнд больше второго.                     |
| 3 | '<='     | Меньше или равно — условие верно, если первый операнд меньше или равен второму. |
| 4 | '>='     | Больше или равно — условие верно, если первый операнд больше или равен второму. |
| 5 | '=='     | Равенство. Условие верно, если два операнда равны.                              |

Например, условие `(x * x < 1000)` означает «значение `x * x` меньше `1000`», а условие `(2 * x != y)` означает «удвоенное значение переменной `x` не равно значению переменной `y`».

Операторы сравнения в можно объединять в цепочки, например, `a == b == c` или `1 <= x <= 10`.

### Тип данных bool

Операторы сравнения возвращают значения специального логического типа `bool`. Значения логического типа могут принимать одно из двух значений: `True` (истина) или `False` (ложь). Если преобразовать логическое `True` к типу `int`, то получится `1`, а преобразование `False` даст `0`. При обратном преобразовании число `0` преобразуется в `False`, а любое ненулевое число в `True`. При преобразовании `str` в `bool` пустая строка преобразовывается в `False`, а любая непустая строка в `True`.

### Каскадные условные инструкции

Пример программы, определяющий четверть координатной плоскости, можно переписать используя «каскадную« последовательность операцией `if... elif... else`:

```python
x = int(input())
y = int(input())
if x > 0 and y > 0:
    print("Первая четверть")
elif x < 0 and y > 0:
    print("Вторая четверть")
elif x < 0 and y < 0:
    print("Третья четверть")
elif x > 0 and y < 0:
    print("Четвертая четверть")
else:
    print("Точка находится на осях или в центре координат.")
```

В такой конструкции условия `if, ..., elif` проверяются по очереди, выполняется блок, соответствующий первому из истинных условий. Если все проверяемые условия ложны, то выполняется блок `else`, если он присутствует. Обратите внимание, что таким образом мы чётче видим условия наступления случаев (нет "призраков"), а также отлавливаем ситуацию, когда точка не находится ни в одной из четвертей.

### Цикл while

Цикл `while` (*«пока»*) позволяет выполнить одну и ту же последовательность действий, пока проверяемое условие истинно. Условие записывается до тела цикла и проверяется до выполнения тела цикла. Как правило, цикл `while` используется, когда невозможно определить точное значение количества проходов исполнения цикла.

Синтаксис цикла `while` в простейшем случае выглядит так:

```python
while Условие:
    Блок_инструкций
```
При выполнении цикла `while` **сначала проверяется условие**. Если оно **ложно**, то выполнение цикла **прекращается** и управление передается **на следующую инструкцию после тела цикла `while`**. Если условие истинно, то выполняется инструкция, после чего условие проверяется снова и снова выполняется инструкция. Так продолжается до тех пор, пока условие будет истинно. Как только условие станет ложно, работа цикла завершится и управление передастся следующей инструкции после цикла.

Например, следующий фрагмент программы напечатает на экран всех целые числа, не превосходящие `n`:

```python
a = 1
while a <= n:
    print(a)
    a += 1
````

Общая схема цикла `while` в данном случае для перебора всех подходящих значений такая:

```python
a = начальное_значение
while а_является_подходящим_числом:
    обработать_a
    перейти_к_следующему_a
```

Выводем все степени двойки, не превосходящие числа n:

```python
a = 1
while a <= n:
    print(a)
    a *= 2
```
### Цикл for

Цикл `for` может быть использован как более краткая альтернатива циклу `while`.
Для последовательного перебора целых чисел из диапазона `[0; n)` можно использовать цикл `for`:

```python
for i in range(10):
    print(i)
```

Этот код по выполняемым действиям полностью соответствуют циклу `while`:

```python
i = 0
while i < 10:
    print(i)
    i += 1
```

Можно задавать начальные и конечные значения для переменной цикла, а также шаг:

```python
for i in range(20, 10, -2):
    print(i)
```  

Аналогичный цикл `while`:

```python
i = 20
while i > 10:
    print(i)
    i -= 2
```

### Запуск и выполнение кода

Для явного указания точки входа используйте следующую конструкцию:

```python
выши_функции

if __name__ == '__main__':
    блок_исполняемого_кода
```

## Черепаха

Стандартная библиотека Python содержит модуль `turtle`, предназначенный для обучения программированию. Этот модуль содержит набор функций, позволяющих управлять черепахой. Черепаха умеет выполнять небольшой набор команд, а именно:

| #  | Команда      | Значение                                                                                |
|----|--------------|-----------------------------------------------------------------------------------------|
| 1  | forward(X)   | Пройти вперёд X пикселей                                                                |
| 2  | backward(X)  | Пройти назад X пикселей                                                                 |
| 3  | left(X)      | Повернуться налево на X градусов                                                        |
| 4  | right(X)     | Повернуться направо на X градусов                                                       |
| 5  | penup()      | Не оставлять след при движении                                                          |
| 6  | pendown()    | Оставлять след при движении                                                             |
| 7  | shape(X)     | Изменить значок черепахи (“arrow”, “turtle”, “circle”, “square”, “triangle”, “classic”) |
| 8  | stamp()      | Нарисовать копию черепахи в текущем месте                                               |
| 9  | color()      | Установить цвет                                                                         |
| 10 | begin_fill() | Необходимо вызвать перед рисованием фигуры, которую надо закрасить                      |
| 11 | end_fill()   | Вызвать после окончания рисования фигуры                                                |
| 12 | width()      | Установить толщину линии                                                                |
| 13 | goto(x, y)   | Переместить черепашку в точку (x, y)                                                    |

Например, следующая программа рисует букву S:

```python
import turtle

turtle.shape('turtle')
turtle.forward(50)
turtle.left(90)
turtle.forward(50)
turtle.left(90)
turtle.forward(50)
turtle.right(90)
turtle.forward(50)
turtle.right(90)
turtle.forward(50)
```
![](http://cs.mipt.ru/python/images/lab2/example.gif)

## Упражнение 1:
Сохраните и выполните предыдущую программу. Убедитесь в том, что черепаха работает.

## Упражнение 2:
Нарисуйте квадрат. Пример:

![](http://cs.mipt.ru/python/images/lab2/rectangle.gif)

## Упражнение 3:
Нарисуйте окружность. Воспользуйтесь тем фактом, что правильный многоугольник с большим числом сторон будет выглядеть как окружность. Пример:

![](http://cs.mipt.ru/python/images/lab2/circle.gif)

## Упражнение 4:
Нарисуйте 10 вложенных квадратов.

![](http://cs.mipt.ru/python/images/lab2/nested_rectangles.gif)

## Упражнение 5:
Нарисуйте паука с n лапами. Пример n = 12:

![](http://cs.mipt.ru/python/images/lab2/spider.gif)

## Упражнение 6:
Нарисуйте спираль. См. [теорию](https://ru.wikipedia.org/wiki/%D0%90%D1%80%D1%85%D0%B8%D0%BC%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0_%D1%81%D0%BF%D0%B8%D1%80%D0%B0%D0%BB%D1%8C)

![](http://cs.mipt.ru/python/images/lab2/spiral.gif)

## Упражнение 7:
Нарисуйте «квадратную» спираль. Пример:

![](http://cs.mipt.ru/python/images/lab2/rect_spiral.gif)

## Написание функций

Как было сказано раньше, функции — это своего рода готовые кирпичики, из которых строится программа. До этого момента мы использовали стандартные функции (`print`, `input`, функции модуля `turtle`), теперь настало время написать функцию:

```python
>>> def hello(name):
...     print('Hello, ', name, '!')
...
>>> hello('world')
Hello,  world!
```
Это простейший пример функции, которая принимает в качестве **параметра** *имя*, а затем выводит на экран сообщение *Hello, <имя>*. Как видно из примера, функции в языке Python описываются при помощи ключевого слова `def`:

```python
def Имя_функции(параметр_1, параметр_2, ...):
    Блок_операций
```

Так же, как и в случае циклов и условных операторов, тело функции выделяется при помощи отступов.
Вызов функции осуществляется по имени с указанием параметров:

```python
hello('world')
```

Внутри функции можно использовать те же синтаксические конструкции, что и вне её — циклы, ветвления, можно даже описывать новые функции. Естественно, внутри функции можно работать и с переменными.

Написанная ранее функция имеет особенность — она просто просто выводит текст на экран и не *возвращает* никакого результата. Многие функции, напротив, занимаются вычислением какого-либо значения, а затем **возвращают** его тому, кто эту функцию вызвал. В качестве примера можно рассмотреть функцию для сложения двух чисел:

```python
>>> def sum(a, b):
...     return a + b
...
>>> sum(1, 2)
3
>>> sum(5, -7)
-2
```
Для возврата значения из функции используется оператор `return`: в качестве параметра указывается значение, которое требуется вернуть.

## Упражнение 8:
Нарисуйте 10 вложенных правильных многоугольников. Используйте функцию, рисующую правильный `n`-угольник. Формулы для нахождения радиуса описанной окружности. Пример:

![](http://cs.mipt.ru/python/images/lab2/regular_polygon.gif)

## Упражнение 9:
Нарисуйте «цветок» из окружностей. Используйте функцию, рисующую окружность. Пример:

![](http://cs.mipt.ru/python/images/lab2/flower.gif)

## Упражнение 10:
Нарисуйте «бабочку» из окружностей. Используйте функцию, рисующую окружность. Пример:

![](http://cs.mipt.ru/python/images/lab2/butterfly.gif)

## Упражнение 11:
Нарисуйте пружину. Используйте функцию, рисующую дугу. Пример:

![](http://cs.mipt.ru/python/images/lab2/spring.gif)

## Упражнение 12:
Нарисуйте смайлик с помощью написанных функций рисования круга и дуги. Пример:

![](http://cs.mipt.ru/python/images/lab2/smile.gif)

## Упражнение 13:
Нарисуйте две звезды: одну с 5 вершинами, другую — с 11. Используйте функцию, рисующую звезду с n вершинами. 
Пример:

![](http://cs.mipt.ru/python/images/lab2/star5.gif)
![](http://cs.mipt.ru/python/images/lab2/star11.gif)

## Красивый код на Python

Важная мысль создателя языка Python, Гвидо ван Россума: код читается намного больше раз, чем пишется.

Поэтому существуют рекомендации о стиле кодирования **PEP8**. Они направлены на то, чтобы улучшить читаемость и сделать его согласованным между большим числом проектов. В идеале, весь код будет написан в едином стиле, и любой сможет легко его прочесть.

На русском можно прочитать про PEP8 [тут](http://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html), на английском — [здесь](https://www.python.org/dev/peps/pep-0008/%22%3Ehttps://www.python.org/dev/peps/pep-0008/).

Материал взят с сайта и адаптирован © http://cs.mipt.ru/python/lessons/lab2.html#id45
